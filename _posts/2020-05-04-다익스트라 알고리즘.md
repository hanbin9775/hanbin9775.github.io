---
layout : post
author : Joel
tag : algorithm
---

다익스트라 알고리즘
==================
<br>
<br>
## 정의

<br>
>음의 가중치가 없는 그래프에서 한 점을 기준으로 그래프의 다른 모든 점까지의 최단경로들을 찾는 알고리즘

<br>
<br>

다익스트라 알고리즘은 적은 비용으로 빠르게 목표점까지 도달하는 경로를 찾아내는 알고리즘을 유명하다. 실재로 실생활에서 응용되는 경우가 많다. 가장 대표적인 예로 네비게이션의 경로 탐색이 있다. 

<br>
<br>
<br>
## 구현
<br>
<br>

다익스트라 알고리즘의 과정을 그림과 함께 살펴보자
<br>
<br>
![Alt text](../../../assets/img/2020-05-04/graph1.jpg){: width="70%" height="70%"}
<br>
<br>
여기선 기준점을 1번 점으로 잡겠다.

즉 이제부터 다익스트라 알고리즘으로 1번 점으로부터 2,3,4,5 번까지의 최소 거리를 구할 것이다.

가장 첫 번째로 할 것은 1에서 각 점까지 한번에 갈 수 있는 거리를 구하는 것이다. 

거리를 한 눈에 보기 쉽게 표로 정리해보겠다.

<br>
<br>
![Alt text](../../../assets/img/2020-05-04/table1.jpg){: width="70%" height="70%"}
<br>
<br>

아 참! 이미 방문한 점은 따로 표시를 해주도록 하자.

<br>
<br>
![Alt text](../../../assets/img/2020-05-04/table2.jpg){: width="70%" height="70%"}
<br>
<br>

그 다음으로 할 것은 방문하지 않은 점중에 가장 작은 값을 가지고 있는 점을 구한다. (여기선 점 2가 값 2로 가장 작다)

그리고 그 점을 거쳐갔을 때 다른 점과의 거리를 구해 미리 구해두었던 값과 비교한다. 그리고 더 작은 값으로 값을 대체한다.

1에서 2까지의 거리는 2이다.

그리고 2에서 출발 했을 때 3,4,5로의 경로의 길이는 각각 3, INF, INF이다.
<br>
<br>
2 + 3 < INF (o)<br>
2 + INF < INF (x)<br>
2 + INF < INF (x)<br>
<br>
<br>
이므로 점 3까지의 거리를 바꿔주면 되는 것이다.

<br>
<br>
![Alt text](../../../assets/img/2020-05-04/table3.jpg){: width="70%" height="70%"}
<br>
<br>

다음 방문하지 않은 점 중에 가장 작은 값을 가진 점은 5이지만 5를 거쳐 다른 점으로 갈 수 없기 때문에 넘어가도록 하자.
<br>
<br>
![Alt text](../../../assets/img/2020-05-04/table4.jpg){: width="70%" height="70%"}
<br>
<br>

다음은 3번점이 기준이다.

위의 과정에서 1번에서 3번까지의 거리가 5로 바뀌었음을 기억하자.
<br>
<br>
![Alt text](../../../assets/img/2020-05-04/table5.jpg){: width="70%" height="70%"}
<br>
<br>

마지막으로 방문하지 않은 4번 점을 기준으로 거리를 다시 구해봐도 값은 바뀌지 않는다. 
<br>
<br>
![Alt text](../../../assets/img/2020-05-04/table6.jpg){: width="70%" height="70%"}
<br>
위의 표가 1번 점을 기준으로 했을 때 각 점으로의 최소 경로의 값이다.

<br>
<br>
## 코드

위의 알고리즘을 코드로 구현해보자.

다익스트라 알고리즘을 코드로 구현하는 방법은 크게 2가지가 있다.

그래프를 이차원 행렬로 그래프를 표현한 뒤 배열을 매번 탐색하여 가장 짧은 거리를 찾는 방법과

우선 순위 큐를 이용하여 매번 탐색할 필요가 없게 만드는 방법이 있다.

이차원 행렬로 구현하면 시간 복잡도는 O(V^2)이고

우선 순위 큐로 구현하면 시간 복잡도는 O(E + VlogV)이다.  (V = 꼭짓점 개수, E = 변의 개수)

따라서 변의 개수가 비정상적으로 많지만 않다면 우선 순위 큐로 구현한 다익스트라 알고리즘이 빠르다.

이 포스팅에서는 위에서 살펴본 알고리즘으로 작동하는 이차원 행렬을 이용해 다익스트라 알고리즘을 정리해보고자 한다. (나중에 우선 순위 큐로 작동하는 알고리즘도 정리하도록 하자)

일단 코드를 구현하기 위해 필요한 것들을 살펴보자.

1. 그래프의 정보를 저장할 이차원 행렬 arr

2. 기준점에서부터 거리를 계속 갱신해줄 dist 배열

3. 방문한 점을 기록할 visit 배열

```c++
#define vertex 5
#define INF 1000000
int arr[vertex][vertex] = {
    {0,   2,   INF, 9,   4},
    {2,   0,   3,   INF, INF},
    {INF, 3,   0,   1,   INF},
    {9,   INF, 1,   0,   INF},
    {4,   INF, INF, INF, 0}
};
int dist[vertex];
int visit[vertex];
```

다음은 dist 배열 내에서 최솟값의 점 인덱스를 반환하는 함수이다.

주의할 것은 방문하지 않은 점들을 대상으로 검사해야하므로 조건문에 꼭 명시해주도록 하자.

```c++
int smallestDist(){
    int min = INF;
    int index = 0;

    for(int i=0; i<vertex;i++){
        if(!visit[i] && dist[i]<min ){
            min = dist[i];
            index = i;
        }
    }

    return index;
}
```

이제 다익스트라 알고리즘 본체를 구현해보자.

위에서 봤던 알고리즘을 그대로 작성하면 된다.


```c++
void dijkstra(int start){
    for(int i=0; i<vertex;i++){
        dist[i] = arr[start][i];
    }
    visit[start] = true;

    for(int i=0; i<vertex-2; i++){
        int cur = smallestDist();
        visit[cur] = true;
        for(int j=0; j<vertex; j++){
            if(!visit[j]){
                if(dist[cur] + arr[cur][j] < dist[j]){
                    dist[j] = dist[cur] + arr[cur][j];
                }
            }
        }
    }
}
```

다시 간단하게 설명하자면

1. dist 배열의 가장 작은 값을 기준으로 방문하고 (cur=smallestDist(), visit[cur]= true)

2. 그 점을 기준으로 방문하지 않은 점을 거쳐가는 것이 다른 점들로 한번에 도착하는 거리보다 작다면 바꿔주면 되는거다. 
(if(dist[cur] + arr[cur][j] < dist[j]){dist[j] = dist[cur] + arr[cur][j];

<br>
<br>
## 더 좋은 방법? 힙!
<br>
위의 방법의 시간 복잡도는 O(V^2)에 수렴하는 것을 볼 수 있다. (V:점의 개수)

V^2 중 V는 한 점으로부터 다른 점의 최소값을 구하느라 매번 V 만큼 실행되어야 함에서 기인한다. (함수 smallestDist) 

이를 최소 힙 자료구조를 이용하면 최소값을 구할 때 V가 아닌 logV 만 소비하는 다익스트라 알고리즘을 구현할 수 있다. 결과부터 말하면 이렇게 구현한 다익스트라 알고리즘은 O((V+E)logV)의 시간복잡도를 가진다.(E: 간선의 개수) 힙을 사용한 다익스트라 알고리즘의 코드는 다음과 같다.

<br>

```c++
struct comp {
	bool operator()(pair<int, int> a, pair<int, int> b) {
		return a.second > b.second;
	}
};

void dijkstra(int start) {
	for (int i = 1; i < vertex; i++) {
		dist[i] = INF;
	}
	dist[start] = 0;

	priority_queue<pair<int, int>, vector<pair<int, int>>, comp> pq;

	pq.push(make_pair(start,0));

	while (!pq.empty()) {
		int cur = pq.top().first;
		visit[cur] = true;
		int distance = pq.top().second;
		pq.pop();

		for (int i = 0; i < vertex; i++) {
			if (!visit[i]) {
				if (dist[cur] + arr[cur][i] < dist[i]) {
					dist[i] = dist[cur] + arr[cur][i];
				}
				if (arr[cur][i] != INF) {
					pq.push(make_pair(i, arr[cur][i]));
				}
			}
		}
	}
}
```
<br>
최소 힙은 우선 순위 큐로 구현하였다.

기본적인 알고리즘은 같다. 다른 점은 최소값을 구할 때 최소 힙 자료구조를 사용했다는 점이다.

<br>
<br>
### 출처 및 참고
<br>

https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%81%AC%EC%8A%A4%ED%8A%B8%EB%9D%BC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98

https://blog.naver.com/ndb796/221234424646