---
layout: post
author: Joel
tag : front
---

ES2020에서 당신이 알아야할 10가지 Javascript 특징들
================================================

<br>
<br>
>이 포스팅은 Mehul Mohan의 10 New Javascript Features in ES2020 That You Should Know를 번역한 글임을 미리 알립니다.

<br>
<br>

좋은 소식입니다! - ES2020의 새로운 기능들이 드디어 마무리 되었습니다. 우리는 이제 ES2020의 모든 변화들과 더욱 발전되고 새로워진 JavaScript를 알게 되었습니다. 지금부터 한번 알아보자구요.

<br>
## 1. BigInt
<br>

자바스크립트에서 가장 기대했던 기능 BigInt가 드디어 나왔습니다. 개발자들은 이제 자바스크립트로 데이터 처리 작업을 할 때, 더욱 더 큰 정수를 표현할 수 있게 되었습니다. 

원래는 자바스크립트에서 우리가 쓸 수 있었던 가장 큰 정수는 2의 53승 -1 ( pow(2, 53)-1 ) 이었습니다. 하지만 BigInt는 이를 훨씬 뛰어넘습니다.

<br>
![Alt text](../../../assets/img/2020-05-27/BigInt.png){: width="70%" height="70%"}
<br>

하지만 위에서 보이는 것처럼 n을 뒤에 붙여야 합니다. 이 n은 자바스크립트 런타임 엔진에 해당 숫자가 BigInt인 정수임을 알리는 역할을 합니다.

기존의 숫자 시스템은 IEEE754 표준을 사용하기 때문에 BigInt 기능은 하위 버전에서 사용할 수 없습니다.

<br>
## 2. Dynamic import
<br>
Dynamic import 기능은 어플리케이션에서 자바스크립트 파일을 동적으로 import 할 것인지에 대한 옵션을 제공합니다. Webpack과 Babel로 하는 것처럼 말이죠.

이 기능은 webpack이나 다른 모듈 번들러의 오버헤드 없이, code splitting으로 더 잘 알려진 on-demand-request 코드를 배포하는데 도움을 줄 것입니다. if-else 블록에서 조건부로 코드를 작성할 수도 있습니다.

실제로 모듈을 임포트해도 전역 namespace를 훼손시키지 않는다는게 장점이지요.

<br>
![Alt text](../../../assets/img/2020-05-27/DynamicImport.png){: width="70%" height="70%"}
<br>

<br>
## 3. Nullish Coalescing
<br>

Nullish Coalescing은 falsey 값들이 아닌 nullish 값들을 점검하는 기능입니다. nullish 값과 falsey 값들이 궁금하실 수 있겠죠?

자바스크립트에서는 많은 값들이 falsey 값입니다. 예를 들어 empty string, 숫자 0, undefined, null, false, Nan 등이 있죠.

하지만 우리는 특정 변수가 nullish인지 undefined인지 null 인지 궁금할 때가 많습니다. 그 변수가 empty string이거나 잘못된 값이 들어와도 괜찮을 때 말이죠.

이런 경우에 우리는 이제 nullish coalescing 연산자, ??를 사용하면 됩니다. 

<br>
![Alt text](../../../assets/img/2020-05-27/nullish.png){: width="70%" height="70%"}
<br>

OR 연산자를 쓰면 항상 truthy 값을 반환하고, nullish 연산자를 쓰면 non-nullish 값을 반환하는 것을 볼 수 있습니다.

<br>
## 4. Optional Chaining
<br>

Optional Chaining 구문은 깊이 nested 된 객체 프로퍼티에 프로퍼티가 실제로 존재하는지에 대한 고민 없이 접근할 수 있게 합니다. 만약 존재한다면, 좋아요! 만약 없다면 undefined가 반환될 것입니다.

객체 프로퍼티 뿐만 아니라 함수나 배열에서도 작동합니다. 짱 편리하네요. 예를 한번 살펴봅시다.

<br>
![Alt text](../../../assets/img/2020-05-27/OptionalChaining.png){: width="70%" height="70%"}
<br>

<br>
## 5. Promise.allSettled
<br>
Promise.allSettled 메서드는 Promise 배열을 인자로 받고 배열의 모든 원소가 모두 settle 됐을 때 resolve 합니다. 

전에 race 나 all 같이 비슷한 메서드는 있었지만 allSettled 메서드의 기능은 없었죠. allSettled 메서드는 "일단 모두 실행시켜. 결과는 상관없으니깐" 과 같은 역할을 한다고 볼 수 있죠.

<br>
![Alt text](../../../assets/img/2020-05-27/allSettled.png){: width="70%" height="70%"}
<br>

<br>
## 6. String#matchAll
<br>
matchAll은 정규 표현식과 관련된 String 프로토타입에 추가된 새로운 메서드입니다. 이 메서드는 그룹에 모두 만족하는 iterator를 하나씩 반환합니다. 짧게 예를 한번 살펴보죠.

<br>
![Alt text](../../../assets/img/2020-05-27/matchall.png){: width="70%" height="70%"}
<br>

<br>
## 7. globalThis
<br>

만약 당신이 Node와 브라우저 환경 그리고 web-worker 안에서 실행되는 cross-platform 자바스크립트 코드를 작성했었다면 전역 객체를 다루는데 힘든 시간을 보내셨을 겁니다.

browser에선 window, Node에선 global, web worker에선 self로 표현하기 때문이죠. 만약 더 많은 런타임이 있다면 전역 객체도 모두 다르겠죠.

그래서 우리는 런타임에 따라 어떤 전역 객체를 사용하는지 확인했어야 했죠. - 지금까진 말이죠.

ES2020은 어디서 실행하든 항상 전역 객체를 반환하는 globalThis를 가져왔습니다. 

<br>
![Alt text](../../../assets/img/2020-05-27/globalThis.png){: width="70%" height="70%"}
<br>

<br>
## 8. Module Namespace Exports
<br>

자바스크립트 모듈에선 다음과 같은 구문을 작성하는 것이 가능했습니다.

```
import * as utils from './utils.mjs'
```

<br>

하지만 지금까진 대칭적인 export 구문이 없었죠.

```
export * as utils from './utils.mjs'
```

<br>
위 코드는 다음과 같습니다.

```
import * as utils from './utils.mjs'
export { utils }
```

<br>
## 9. Well defined for-in order
<br>

ECMA 사양은 for (x in y)가 어떤 순서로 실행되야 하는지 특정하지 않았었죠. 브라우저만의 일관된 순서로 이를 실행했다면 지금은 공식적으로 ES2020에서 표준화하였습니다.

<br>
## 10. import.meta
<br>

import.meta 객체가 null 프로토타입과 함께 ECMAScript에서 생성되었습니다.

module.js 모듈을 예로 들어보죠.

```
<script type="module" src="module.js"></script>
```

<br>

이제 import.meta 모듈을 사용해서 meta 정보에 접근할 수 있습니다.

```
console.log(import.meta); // { url: "file:///home/user/module.js" }
```

<br>

객체를 모듈의 base url을 명시하는 url 프로퍼티와 함께 객체를 반환합니다. 외부 스크립트의 경우 스크립트가 얻어진 url이거나 이를 포험하고 있는 문서의 base url입니다.

<br>
### 출처

<https://www.freecodecamp.org/news/javascript-new-features-es2020/>