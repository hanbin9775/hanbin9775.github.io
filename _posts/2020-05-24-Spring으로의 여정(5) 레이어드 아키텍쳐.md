---
layout: post
author: Joel
tag : back
---

Spring 레이어드 아키텍쳐
=======================
<br>
<br>
> 이 글은 '부스트코스'의 강의 내용의 흐름을 따라가며 작성했음을 미리 밝힙니다.

<br>
<br>
<br>
<br>

프로그래밍을 할 때 기능이 중복되는 경우 우리는 보통 중복되는 부분을 따로 만들어놔 필요할 때마다 가져다 쓰는 방식을 취한다.

우리는 보통 별도의 객체로 분리하거나, 별도의 메소드, 함수로 분리하는 방식을 취해서 위 문제를 해결한다.

그렇다면 Spring의 컨트롤러에서 중복되는 부분은 어떻게 처리할까? 

Spring 컨트롤러에서도 마찬가지다. 별도의 객체와 메소드로 분리한다.

Spring에서는 이렇게 분리되는 객체를 <strong>Service 객체<strong>라 부른다. 그리고 이 객체에서 수행되는 메서드의 로직을 <strong>비즈니스 로직</strong>이라고 부른다. 보통 하나의 비즈니스 로직은 하나의 트랜잭션으로 동작한다.

<br>
## 트랜잭션?
<br>

트랜잭션은 다음과 같은 특징을 갖는 하나의 논리적인 작업을 의미한다. 

<br>
### 원자성
<br>
전체가 성공하거나 전체가 실패하는 것을 의미한다.

예를 들어 출금이라는 기능을 수행할 때 

1. 잔액 조회
2. 잔액보다 출금 희망액이 작은지 검사
3. 잔액을 잔액-출금액으로 수정
4. 언제 어디서 출금했는지 기록
5. 출금

위와 같은 과정에서 하나라도 오류가 발생한다면 출금이라는 기능은 수행돼서는 안된다. 

<br>
### 일관성
<br>
말 그대로 작업 처리 결과가 항상 일관성이 있어야 한다는 것이다. 트랜잭션이 진행되는 동안에 데이터가 변경되더라고 업데이트된 데이터로 트랜잭션이 진행되는 것이 아니라, 처음에 트랜잭션을 진행하기 위해 참조한 데이터로 진행된다. 

<br>
### 독립성
<br>
둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 경우에 어느 하나의 트랜잭션이라도 다른 트래잭션의 연산을 끼어들 수 없다는 것을 의마한다.

<br>
### 지속성
<br>
트랜잭션이 성공적으로 완료됐을 경우 결과는 영구적으로 반영되어야 한다는 점이다.

<br>
## 적용
<br>
트랜잭션을 적용하는 것은 간단하다. 

JDBC 프로그래밍의 경우 DB에 견결된 후 Connection 객체의 SetAutoCommit메소드에 false를 파라미터로 저장한다. 그리고 입력, 수정, 삭제 SQL이 실행을 한 후 모두 성공했을 경우에 Connection 객체가 가지고 있는 commit() 메서드를 호출하면 된다. 

Spring에서는 Java Config 파일에서 @EnableTransactionManagement 어노테이션을 사용한다. 특정 트랜잭션 매니저를 사용하고자 한다면 TransactionManagementConfigurer를 Java Config 파일에서 구현하고 원하는 트랜잭션 매니저를 리턴하도록 한다. 아니면 특정 트랜잭션 매니저 객체를 생성시 @Primary 어노테이션을 지정한다.

뒤에서 직접 해보도록 하자.

<br>
## 서비스 객체에서도 중복으로 호출되는 코드가 있다면?
<br>

<strong>이 때도 별도의 객체나 메서드로 분리한다. 이렇게 분리된 객체를 Repository 객체라고 부른다.</strong>

분명 전에도 컨트롤러 객체를 구현할 때 중복되는 객체와 메서드를 별도로 구현했었다. 똑같은 상황이라고 보면 된다.

<br>
![Alt text](../../../assets/img/2020-05-24/3layers.jpg){: width="70%" height="70%"}
<br>

위의 내용을 다시 정리해보자.

컨트롤러 객체에서 호출하는 중복되는 코드를 관리하기 위해 서비스 객체를 만들었고 다시 서비스 객체에서 호출하는 중복되는 코드를 관리하기 위해 repository 객체를 만들었다. 이 3가지 객체를 각각 Presentation Layer, Service Layer, Repository Layer에서 관리하는 아키텍쳐가 Spring의 레이어드 아키텍쳐이다.


<br>
<br>
### 출처 및 참고
<br>
<https://www.edwith.org/boostcourse-web/lecture/16767/>
